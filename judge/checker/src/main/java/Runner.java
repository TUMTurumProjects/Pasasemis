import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;
import com.google.gson.*;

import java.io.*;
import java.util.LinkedList;
import java.util.List;

public class Runner {
    static JUnitCore junitCore;
    static Class<?> testClasses;

    public static void main(String[] args) {
        /**
         * Running Junit tests and creating a Json report
         */
        String className = args[0];
        try {
            Class<?> testClass = Class.forName(className);
            System.err.println("Running Junit Test Suite.");
            TestManager tm = new TestManager(testClass);
            tm.start();
            if (!isOk(tm)) System.exit(1);
            Result result = tm.getResult();
            boolean passed = result.wasSuccessful();
            long time = result.getRunTime();
            int failed = result.getFailureCount();
            int ran = result.getRunCount();
            LinkedList<String> messages = new LinkedList<String>();
            for (Failure failure : result.getFailures()) {
                String testName = failure.getDescription().toString();
                testName = testName.substring(0, testName.length() - Settings.TESTING_FILE_NAME_LENGTH());
                messages.add(testName + " : " + failure.getMessage());
            }
            postJson(new TestResult(passed, time, messages, failed, ran, ""));
        } catch (ClassNotFoundException e) {
            System.err.println("Could not load the test class file.");
            try (Writer w = new BufferedWriter(new FileWriter("errors.txt"))) {
                w.write("Unit tests ran");
            } catch (IOException e2) {
                //todo future handle for errors
            }
        } catch (IllegalThreadStateException e) {
            //todo debug
        }
        System.exit(1);
    }

    private static class TestResult {
        private boolean passed_overall;
        private long time;
        private String passed_tests;
        private List<String> messages;
        private String error;

        /**
         * @param passed_overall determines if all tests have been passed
         * @param time           time it takes to run all tests
         * @param messages       messages generated by all failures from test methods
         * @param failedCount    amount of tests failed
         * @param runCount       amount of tests ran
         * @param error          testing system error, Possible codes : TL
         */
        TestResult(boolean passed_overall, long time, List<String> messages, int failedCount, int runCount, String error) {
            this.passed_overall = passed_overall;
            this.time = time;
            this.messages = messages;
            this.passed_tests = (runCount - failedCount) + "/" + runCount;
            this.error = error;
        }
    }


    /**
     * Writing the test result to result.json
     *
     * @param res test results
     */
    private static void postJson(TestResult res) {
        try (Writer writer = new FileWriter(Settings.JSON_RESULT_NAME())) {
            Gson gson = new GsonBuilder().create();
            gson.toJson(res, writer);
        } catch (IOException e) {
            System.out.println("Could not create a json file");
        }
    }

    /**
     * @param allowedTime when tl is exceeded post the total allowed test time back to the result.json file
     */
    private static void postTL(int allowedTime) {
        postJson(new TestResult(false, allowedTime, new LinkedList<String>(), 0, 0, "TL"));
    }

    private static void postSecurityError(SecurityException e) {
        postJson(new TestResult(false, 0, new LinkedList<String>(), 0, 0, "Security alert : " + e.getMessage()));
    }

    private static boolean isOk(TestManager tm) {
        if (tm.timedOut()) {
            postTL(tm.getAllowedTime());
            return false;
        }
        if (!tm.isSecure()) {
            postSecurityError(new SecurityException("Unauthorized access"));
            return false;
        }
        return true;
    }


}
